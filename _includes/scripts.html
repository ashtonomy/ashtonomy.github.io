<script type="module" src="{{ base_path }}/assets/js/main.min.js"></script>

{% include analytics.html %}

<!-- Load Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>

<!-- Network animation -->
<script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  let vantaEffect;

  function customizeVantaInstance(effect) {
    /* A) Slower / controllable mouse sensitivity */
    if (!effect._mouseWrapped) {
      effect._originalOnMouseMove = effect.onMouseMove;
      effect.onMouseMove = function (t, e) {
        const sensx = this.options.mouseSensitivityX ?? 1.0; /* one knob */
        const sensy = this.options.mouseSensitivityY ?? 1.0; /* one knob */
        const nx = 0.5 + (t - 0.5) * sensx;
        const ny = 0.5 + (e - 0.5) * sensy;
        /* call the stored original handler */
        this._originalOnMouseMove.call(this, nx, ny);
      };
      effect._mouseWrapped = true;
    }
    /* B) Alpha + center density + line color, applied once the geometry exists */
    function applyVisualTweaks() {
      if (!effect.points || !effect.linesMesh) {
        requestAnimationFrame(applyVisualTweaks);
        return;
      }

      const alphaOpt =
        effect.options.alpha ?? effect.options.networkAlpha;
      const alpha = (typeof alphaOpt === 'number') ? alphaOpt : 0.3;

      const falloff = effect.options.centerFalloff ?? 1.6;

      /* 1) Global alpha for dots (nodes) */
      effect.points.forEach(p => {
        if (p.material) {
          p.material.transparent = true;
          p.material.opacity = alpha;   /* <- only nodes use this alpha */
          p.material.needsUpdate = true;
        }
      });

      /* 2) Global alpha + sane blending for lines (edges) */
      if (effect.linesMesh.material) {
        const m = effect.linesMesh.material;
        m.transparent = true;
        m.opacity = alpha;              /* <- only edges use this alpha */
        m.blending = THREE.NormalBlending; /* or THREE.AdditiveBlending for glow */
        m.depthWrite = false;
        m.needsUpdate = true;
      }

      /* 3) Denser near center, sparser at edges (XZ plane) */
      if (!effect._densityBaseSaved) {
        effect.points.forEach(p => {
          // Use Vanta's ox/oz if present, otherwise current position
          p._baseX = (typeof p.ox === 'number') ? p.ox : p.position.x;
          p._baseZ = (typeof p.oz === 'number') ? p.oz : p.position.z;
        });
        effect._densityBaseSaved = true;
      }

      let maxR = 0;
      effect.points.forEach(p => {
        const r = Math.hypot(p._baseX, p._baseZ);
        if (r > maxR) maxR = r;
      });

      if (maxR > 0) {
        effect.points.forEach(p => {
          const r0 = Math.hypot(p._baseX, p._baseZ);
          if (!r0) return;

          const rNorm   = r0 / maxR;           // 0 center â†’ 1 edge
          const newNorm = Math.pow(rNorm, falloff);
          const newR    = maxR * newNorm;
          const s       = newR / r0;

          // Position is always recomputed from base, so no accumulation
          p.position.x = p._baseX * s;
          p.position.z = p._baseZ * s;
        });
      }

      /* 4) Make all line colors match node color */
      if (effect.linesMesh.geometry?.attributes?.color) {
        const col = new THREE.Color(effect.options.color);
        const arr = effect.linesMesh.geometry.attributes.color.array;
        for (let i = 0; i < arr.length; i += 3) {
          arr[i]     = col.r;
          arr[i + 1] = col.g;
          arr[i + 2] = col.b;
        }
        effect.linesMesh.geometry.attributes.color.needsUpdate = true;
      }
    }

    applyVisualTweaks();
  }

  function initVantaForTheme(theme) {
    const isDark = theme === 'dark';

    const baseOptions = {
      el: '#vanta-bg',
      color: isDark ? 0x861d34 : 0xe5bbbb,
      backgroundColor: isDark ? 0x3031f : 0xffffff,
      points: 9.00, /* Default 10 */
      maxDistance: 19.00, /* Default 20 */
      mouseSensitivityX: 0.15, /* lower = slower rotation */
      mouseSensitivityY: 0.75, 
      alpha: 0.5,         /* lower = more subtle */
      centerFalloff: 1.12         /* >1 = denser center, sparser edges */
    };

    if (!window.VANTA || !VANTA.NET) return;

    if (vantaEffect) {
      /* Update existing instance when theme changes */
      vantaEffect.setOptions(baseOptions);
      /* optional: re-run visual tweaks if you want alpha to update immediately */
      customizeVantaInstance(vantaEffect);
    } else {
      /* First-time creation */
      vantaEffect = VANTA.NET(baseOptions);
      customizeVantaInstance(vantaEffect);
    }
  }

  const themeEl = document.documentElement; 
  const initialTheme = themeEl.getAttribute('data-theme') || 'light';
  initVantaForTheme(initialTheme);

  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      if (m.type === 'attributes' && m.attributeName === 'data-theme') {
        const newTheme = themeEl.getAttribute('data-theme') || 'light';
        initVantaForTheme(newTheme);
      }
    }
  });

  observer.observe(themeEl, {
    attributes: true,
    attributeFilter: ['data-theme']
  });
});
</script>
