<script type="module" src="{{ base_path }}/assets/js/main.min.js"></script>

{% include analytics.html %}

<!-- Boids by Alfred Hitchcock -->

<!-- Load Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>

<!-- Load Vanta Birds -->
<!-- <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.birds.min.js"></script> -->

<!-- Network animation -->
<script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>

<!-- <script>
window.addEventListener("load", function () {

    // ⬇ Patch START (you do NOT set values here)
    const NetProto = VANTA.NET.prototype;

    // Slow rotation patch
    NetProto.onMouseMove = function (t, e) {
        const sens = this.options.mouseSensitivity ?? 0.2;
        const cam = this.camera;

        if (!cam.oy) {
            cam.oy = cam.position.y;
            cam.ox = cam.position.x;
            cam.oz = cam.position.z;
        }

        const angle = Math.atan2(cam.oz, cam.ox);
        const radius = Math.sqrt(cam.oz**2 + cam.ox**2);

        const horiz = 2 * sens;
        const vert    = 50 * sens;

        const n = angle + horiz * (t - 0.5);
        cam.tz = radius * Math.sin(n);
        cam.tx = radius * Math.cos(n);
        cam.ty = cam.oy + vert * (e - 0.5);

        this.rcMouseX = 2 * t - 1;
        this.rcMouseY = 2 * e - 1;
    };

    // Density falloff patch
    const originalInit = NetProto.onInit;
    NetProto.onInit = function () {
        originalInit.call(this);

        const falloff = this.options.centerFalloff ?? 1.8;

        let maxR = 0;
        this.points.forEach(p => {
            const r = Math.sqrt(p.position.x**2 + p.position.z**2);
            p._r0 = r;
            if (r > maxR) maxR = r;
        });

        this.points.forEach(p => {
            const r0 = p._r0;
            if (!r0 || !maxR) return;
            const rNorm = r0 / maxR;
            const newNorm = Math.pow(rNorm, falloff);
            const newR = maxR * newNorm;
            const scale = newR / r0;

            p.position.x *= scale;
            p.position.z *= scale;
            p.ox *= scale;
            p.oz *= scale;
        });

        // Apply global opacity patch
        const alpha = this.options.networkAlpha ?? 0.35;

        this.points.forEach(p => {
            if (p.material) {
                p.material.transparent = true;
                p.material.opacity = alpha;
                p.material.needsUpdate = true;
            }
        });

        if (this.linesMesh?.material) {
            const mat = this.linesMesh.material;
            mat.transparent = true;
            mat.opacity = alpha;
            mat.depthWrite = false;
            mat.needsUpdate = true;
        }
    };

    VANTA.NET({
        el: "#vanta-bg",
        color: 0xe5bbbb,
        backgroundColor: 0xffffff,

        mouseSensitivity: 0.05,
        centerFalloff: 1.8,
        networkAlpha: 0.35
    });
});
</script> -->

<!-- Your customization -->
<!-- <script>
window.addEventListener('DOMContentLoaded', function () {
    const theme = document.documentElement.getAttribute('data-theme');
    let vantaEffect;
    var isDark = theme === "dark";
    
    def customizeVantaInstance(effect) {
            const originalOnMouseMove = effect.onMouseMove.bind(effect);
    effect.onMouseMove = function (t, e) {
        const sens = this.options.mouseSensitivity ?? 0.2;

        // compress mouse coordinates toward the center
        const nx = 0.5 + (t - 0.5) * sens;
        const ny = 0.5 + (e - 0.5) * sens;

        originalOnMouseMove(nx, ny);
    };

    // 3) Apply alpha, density, and line color once everything is ready
    function applyVisualTweaks() {
        // Wait until Vanta has created points and lines
        if (!effect.points || !effect.linesMesh) {
            requestAnimationFrame(applyVisualTweaks);
            return;
        }

        const alpha     = effect.options.networkAlpha ?? 0.3;
        const falloff = effect.options.centerFalloff ?? 1.8;

        // 3a) Global alpha for dots
        effect.points.forEach(p => {
            if (p.material) {
                p.material.transparent = true;
                p.material.opacity = alpha;
                p.material.needsUpdate = true;
            }
        });

        // 3b) Global alpha for lines
        if (effect.linesMesh.material) {
            const m = effect.linesMesh.material;
            m.transparent = true;
            m.opacity = alpha;
            m.depthWrite = false;
            m.needsUpdate = true;
        }

        // 3c) Pull points toward center (denser middle, sparser edges)
        let maxR = 0;
        effect.points.forEach(p => {
            const r = Math.hypot(p.position.x, p.position.z);
            p._r0 = r;
            if (r > maxR) maxR = r;
        });

        if (maxR > 0) {
            effect.points.forEach(p => {
                const r0 = p._r0;
                if (!r0) return;
                const rNorm     = r0 / maxR;                            // 0 = center, 1 = edge
                const newNorm = Math.pow(rNorm, falloff);
                const newR        = maxR * newNorm;
                const scale     = newR / r0;

                p.position.x *= scale;
                p.position.z *= scale;
                if (p.ox !== undefined) p.ox *= scale;
                if (p.oz !== undefined) p.oz *= scale;
            });
        }

        // 3d) Make line color match node color
        if (effect.linesMesh.geometry &&
                effect.linesMesh.geometry.attributes &&
                effect.linesMesh.geometry.attributes.color) {

            const col = new THREE.Color(effect.options.color);
            const arr = effect.linesMesh.geometry.attributes.color.array;

            for (let i = 0; i < arr.length; i += 3) {
                arr[i]         = col.r;
                arr[i + 1] = col.g;
                arr[i + 2] = col.b;
            }
            effect.linesMesh.geometry.attributes.color.needsUpdate = true;
        }
    

    }

    // For dark/light mode support, we need to init vanta in function
    vantaEffect = VANTA.NET({
        el: "#vanta-bg",
        color: 0xe5bbbb,
        backgroundColor: isDark ? 0x000540 : 0xffffff,
        points: 9.00, // Default 10
        maxDistance: 19.00, // Default 20
        mouseSensitivity: 0.175, // lower = slower rotation
        networkAlpha: 0.5,         // lower = more subtle
        centerFalloff: 1.2         // >1 = denser center, sparser edges
    });

    // 2) Slow the mouse movement by wrapping onMouseMove

    applyVisualTweaks();

    const observer = new MutationObserver((mutations) => {
        for (const m of mutations) {
            if (m.type === 'attributes' && m.attributeName === 'data-theme') {
                const newTheme = el.getAttribute('data-theme') || 'light';
                
        }
    }
});

observer.observe(el, {
        attributes: true,
        attributeFilter: ['data-theme']
});


});
</script> -->


<!-- <div id="vanta-bg" style="width:100%;height:100vh;"></div> -->

<!-- <script>
document.addEventListener("DOMContentLoaded", function () {
    VANTA.BIRDS({
        el: "#vanta-bg",
        mouseControls: true,
        touchControls: true,
        gyroControls: false,
        minHeight: 200.00,
        minWidth: 200.00,
        scale: 1.00,
        scaleMobile: 1.00,
        backgroundColor: 0xffffff,
        color1: 0x7883ff,
        color2: 0x7de7ff,
        colorMode: "lerp",
        wingSpan: 27.00,
        speedLimit: 3.00,
        separation: 51.00,
        alignment: 18.00,
        quantity: 4.00,
        backgroundAlpha: 0.16
    });
});
</script> -->







<script>
document.addEventListener('DOMContentLoaded', () => {
  let vantaEffect;

  // ---- Helper: customize one Vanta instance (mouse, alpha, density, colors) ----
  function customizeVantaInstance(effect) {
    // A) Slower / controllable mouse sensitivity
    if (!effect._mouseWrapped) {
      effect._originalOnMouseMove = effect.onMouseMove;
      effect.onMouseMove = function (t, e) {
        const sensx = this.options.mouseSensitivityX ?? 1.0; // one knob
        const sensy = this.options.mouseSensitivityY ?? 1.0; // one knob
        const nx = 0.5 + (t - 0.5) * sensx;
        const ny = 0.5 + (e - 0.5) * sensy;
        // call the stored original handler
        this._originalOnMouseMove.call(this, nx, ny);
      };
      effect._mouseWrapped = true;
    }
    // B) Alpha + center density + line color, applied once the geometry exists
    function applyVisualTweaks() {
      if (!effect.points || !effect.linesMesh) {
        requestAnimationFrame(applyVisualTweaks);
        return;
      }

      const alphaOpt =
        effect.options.alpha ?? effect.options.networkAlpha;
      const alpha = (typeof alphaOpt === 'number') ? alphaOpt : 0.3;

      const falloff = effect.options.centerFalloff ?? 1.6;

      // 1) Global alpha for dots (nodes)
      effect.points.forEach(p => {
        if (p.material) {
          p.material.transparent = true;
          p.material.opacity = alpha;   // <- only nodes use this alpha
          p.material.needsUpdate = true;
        }
      });

      // 2) Global alpha + sane blending for lines (edges)
      if (effect.linesMesh.material) {
        const m = effect.linesMesh.material;
        m.transparent = true;
        m.opacity = alpha;              // <- only edges use this alpha
        m.blending = THREE.NormalBlending; // or THREE.AdditiveBlending for glow
        m.depthWrite = false;
        m.needsUpdate = true;
      }

      // 3) Denser near center, sparser at edges (XZ plane)
      let maxR = 0;
      effect.points.forEach(p => {
        const r = Math.hypot(p.position.x, p.position.z);
        p._r0 = r;
        if (r > maxR) maxR = r;
      });

      if (maxR > 0) {
        effect.points.forEach(p => {
          const r0 = p._r0;
          if (!r0) return;
          const rNorm   = r0 / maxR;              // 0 center → 1 edge
          const newNorm = Math.pow(rNorm, falloff);
          const newR    = maxR * newNorm;
          const s       = newR / r0;

          p.position.x *= s;
          p.position.z *= s;
          if (p.ox !== undefined) p.ox *= s;
          if (p.oz !== undefined) p.oz *= s;
        });
      }

      // 4) Make all line colors match node color
      if (effect.linesMesh.geometry?.attributes?.color) {
        const col = new THREE.Color(effect.options.color);
        const arr = effect.linesMesh.geometry.attributes.color.array;
        for (let i = 0; i < arr.length; i += 3) {
          arr[i]     = col.r;
          arr[i + 1] = col.g;
          arr[i + 2] = col.b;
        }
        effect.linesMesh.geometry.attributes.color.needsUpdate = true;
      }
    }

    applyVisualTweaks();
  }

  // ---- Initialize / update Vanta based on data-theme ----
  function initVantaForTheme(theme) {
    const isDark = theme === 'dark';

    const baseOptions = {
      el: '#vanta-bg',
      color: isDark ? 0x861d34 : 0xe5bbbb,
      backgroundColor: isDark ? 0x3031f : 0xffffff,
      points: 9.00, // Default 10
      maxDistance: 19.00, // Default 20
      mouseSensitivityX: 0.15, // lower = slower rotation
      mouseSensitivityY: 0.75, 
      alpha: 0.5,         // lower = more subtle
      centerFalloff: 1.12         // >1 = denser center, sparser edges
    };

    if (!window.VANTA || !VANTA.NET) return;

    if (vantaEffect) {
      // Update existing instance when theme changes
      vantaEffect.setOptions(baseOptions);
      // optional: re-run visual tweaks if you want alpha to update immediately
      customizeVantaInstance(vantaEffect);
    } else {
      // First-time creation
      vantaEffect = VANTA.NET(baseOptions);
      customizeVantaInstance(vantaEffect);
    }
  }

  // ---- Read initial theme and observe changes on data-theme ----
  const themeEl = document.documentElement; // <html data-theme="...">
  const initialTheme = themeEl.getAttribute('data-theme') || 'light';
  initVantaForTheme(initialTheme);

  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      if (m.type === 'attributes' && m.attributeName === 'data-theme') {
        const newTheme = themeEl.getAttribute('data-theme') || 'light';
        initVantaForTheme(newTheme);
      }
    }
  });

  observer.observe(themeEl, {
    attributes: true,
    attributeFilter: ['data-theme']
  });
});
</script>
